### 클라이언트의 요청 메시지를 전부 읽은 다음 request로 파싱해야 하나, 읽으면서 파싱 해야 하나

전부 읽으려면 http request의 끝을 알아야 하는데,
메시지 바디가 있다면 Content-Length 헤더가 있는지로 구분해야 한다.
그리고 메시지 바디를 Content-Length 만큼 읽어야 한다.
-> 결국 읽으면서 request를 만들어야 딱 맞게 끝낼 수 있다.

> start-line 읽고, 유효하지 않은 데이터라면 에러 발생시키는 걸로 정했다.

---

### 브라우저의 html, js, css 요청을 모두 응답했지만, 브라우저는 이를 제대로 렌더링하지 못했다.

응답의 content-type 헤더를 잘못 입력했기 때문이다.

각각의 파일의 응답은 `text/html`, `application/javascript`, `text/css`를 입력해줘야 한다.

> 나는 처음에 지속적인 연결 기능을 구현하지 못해 이런 문제가 발생했다 생각했다.
